## A. Деккардова организация (1 балл)

Доминик решил пересмотреть свой автопарк и организовать информацию о нем. Для этого он пронумеровал свои машины последовательными целыми числами от 1 до N, а также присвоил каждой машине ключ и приоритет. Доминик уверен, что если расположить машины как вершины в декартовом дереве поиска, то он сможет подбирать нужную тачку на гонку оптимально.

Так как Доминик, как и всегда, торопится на встречу с семьёй, ему нужно построить дерево для хранения информации о машинах за линейное время от числа машин.

### Формат ввода

В первой строке записано число N — количество пар ключ-приоритет. Далее следует N (1 ≤ N ≤ 50000) пар (ai, bi), где ai задаёт ключ i-й машины, а bi — приоритет. Для всех пар |ai|, |bi| ≤ 30 000. Более того, ai ≠ aj и bi ≠ bj для всех i ≠ j. Гарантируется, что пары отсортированы по возрастанию ai.

### Формат вывода

Если Доминик выбрал неверные приоритеты или ключи и дерево построить невозможно, то выведите `NO`. Иначе выведите `YES`, а затем N строк, каждая из которых должна описывать вершину (номером вершины считаем номер машины, которую она задаёт). Описание вершины состоит из трёх чисел: номер предка, номер левого сына и номер правого сына. Если у вершины отсутствует предок или какой-либо из сыновей, то выводите на его месте число 0.

Если подходящих деревьев несколько, выведите любое.

## B. Заниженная граница (AVL) (2 балла, с ревью)

Реализуйте AVL-дерево.

Доминик проводит инвентаризацию (опять). Он уверен, что машины можно и нужно сравнить по числу миллисекунд для разгона от нуля до 100 км/ч. Он просит вас помочь ему, а именно, ваш алгоритм должен работать с множеством машин Доминика. Нужно реализовать следующие операции:

- `add(i)` — добавить в множество машин тачку с разгоном в i миллисекунд (если такая там уже есть, то Доминик отвлекся на семейные разговоры и подсунул вам второй раз ту же машину);
- `next(i)` — узнать машину с минимальным временем разгона, не меньшим i. Если искомая машина отсутствует, необходимо вывести -1 и попросить Доминика быть внимательнее.

### Формат ввода

Исходно множество машин пусто. Первая строка входного файла содержит число n — количество запросов Доминика (1 ≤ n ≤ 3 ⋅ 10^5).

Следующие n строк содержат операции. Каждая операция имеет вид:

- `+ i` — `add(i)`
- `? i` — `next(i)`

Если операция `+` идет во входном файле в начале или после другой операции `+`, то она задает операцию `add(i)`. Если же она идет после запроса `? i` и результат этого запроса был y, то выполняется операция `add(i)`. Это нужно, чтобы Доминик убедился в том, что вы достойный член семьи и не реализовали оффлайн алгоритм.

Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10^9.

### Формат вывода

Для каждого запроса выведите одно число — ответ на запрос.

## C. Водитель машину красит (3 балла, с ревью)

В этой задаче запрещено использовать `map`, `set` и аналогичные встроенные структуры.

Очередная гонка, в этот раз вам предстоит разработать модуль соответствия гонщик-тачка. Каждый гонщик имеет свой уникальный позывной и машину, для которой водитель придумал уникальное имя. Гарантируется, что все имена и позывные попарно различны.

### Формат ввода

Программа получает на вход количество участников в виде позывной гонщика — имя машины `N` (0 ≤ N ≤ 10^5). Далее следует N строк, каждая строка содержит ровно два слова.

Затем идет число `Q` (1 ≤ Q ≤ 10^5) — количество запросов к модулю. Далее на каждой следующей из Q строк идет слово, к которому надо вывести, если на входе имя, соответствующее позывной гонщика, иначе — имя машины, соответствующей гонщику.

### Формат вывода

Программа должна вывести на отдельных строках результаты запросов.

## D. Дерево настроения семьи (3 балла, с ревью)

Реализуйте декартово дерево. Для получения 5 баллов за задачу можно вместо этого реализовать B-дерево или красно-чёрное дерево.

В этой задаче вам предстоит доказать, что вы достойный член семьи. А именно, вам предстоит реализовать сбалансированное дерево семьи.

### Формат ввода

Входной файл содержит описание операций с деревом семьи, их количество не превышает 10^5. В каждой строке находится одна из следующих операций:

- `insert x` — добавить в дерево члена семьи с настроением x. Если такой уже есть, то ничего делать не надо.
- `delete x` — удалить из дерева члена семьи с настроением x. Если его там нет, то ничего делать не надо.
- `exists x` — если имеется член семьи с настроением x, выведите `true`, иначе — `false`.
- `next x` — выведите настроение такого члена семьи, что оно лучше чем x, но минимально среди таких или `none`, если такого нет. Это нужно, чтобы понимать, кого на предстоящую гонку можно брать в команду, а кому надо отдохнуть.
- `prev x` — выведите настроение такого члена семьи, что оно хуже чем x, но максимально среди таких или `none`, если такого нет.
- `kth k` — выведите k-ю величину настроения (нумерация с нуля). Если такого не существует, то выведите `none`.

Все числа во входном файле по модулю не превышают 10^9.

### Формат вывода

Выведите последовательно результат выполнения всех операций выше. Следуйте формату выходного файла из примера.

## F. Подсемья и ее сумма (2 балла)

«Нельзя отворачиваться от семьи. Даже если она отвернулась от тебя» (c) Форсаж 6. Все дороги принадлежат им!

Вы решили собрать всю семью вместе, чтобы узнать, как у них настрой. Пока еще никто не приехал (семья же отвернулась), но вот-вот они будут тут. Вы хотите понимать, каково суммарное настроение у семьи и ее подсемей. Для этого вы хотите уметь следующие вещи:

- `add(i)` — обработать приезд нового члена семьи с настроем i (если он там уже есть, то состав приехавших не изменился, и было введено ошибочное значение);
- `sum(l, r)` — вывести суммарное настроение всех членов с настроем x, которые удовлетворяют неравенству `l ≤ x ≤ r`.

### Формат ввода

Изначально никто не прибыл еще. Первая строка входного файла содержит n — количество запросов (1 ≤ n ≤ 300 000). Следующие n строк содержат операции. Каждая операция имеет вид либо «+ i», либо «? l r». Операция «? l r» задает запрос `sum(l, r)`.

Если операция «+ i» идет во входном файле в начале или после другой операции «+», то она задает операцию `add(i)`. Если же она идет после запроса «?», и результат этого запроса был y, то выполняется операция `add(i)`.

Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10^9.

### Формат вывода

Для каждого запроса выведите одно число — ответ на запрос.
